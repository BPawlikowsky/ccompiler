// C89 Refined LL(1) Grammar
// Optimized for LL(1) parsing and generator compatibility.

start:
<p>translation_unit</p>

// --- TOP LEVEL ANCHORS ---
translation_unit:
<p>external_declaration translation_unit_tail</p>

translation_unit_tail:
<p>external_declaration translation_unit_tail</p>
<p>epsilon</p>

external_declaration:
<p>declaration_specifiers external_tail</p>
<p>declarator function_tail</p>

external_tail:
<p>declarator external_decl_branch</p>
<p>;</p>

external_decl_branch:
<p>declaration_list_opt compound_statement</p>
<p>init_declarator_list_tail ;</p>
<p>;</p>

function_tail:
<p>declaration_list_opt compound_statement</p>

// --- STATEMENTS ---
statement:
<p>labeled_statement</p>
<p>compound_statement</p>
<p>expression_statement</p>
<p>selection_statement</p>
<p>iteration_statement</p>
<p>jump_statement</p>

labeled_statement:
<p>IDENTIFIER : statement</p>
<p>CASE constant_expression : statement</p>
<p>DEFAULT : statement</p>

compound_statement:
<p>{ declaration_list_opt statement_list_opt }</p>

declaration_list_opt:
<p>declaration_list</p>
<p>epsilon</p>

statement_list_opt:
<p>statement_list</p>
<p>epsilon</p>

declaration_list:
<p>declaration declaration_list_tail</p>

declaration_list_tail:
<p>declaration declaration_list_tail</p>
<p>epsilon</p>

statement_list:
<p>statement statement_list_tail</p>

statement_list_tail:
<p>statement statement_list_tail</p>
<p>epsilon</p>

expression_statement:
<p>expression_opt ;</p>

expression_opt:
<p>expression</p>
<p>epsilon</p>

selection_statement:
<p>IF ( expression ) statement else_opt</p>
<p>SWITCH ( expression ) statement</p>

else_opt:
<p>ELSE statement</p>
<p>epsilon</p>

iteration_statement:
<p>WHILE ( expression ) statement</p>
<p>DO statement WHILE ( expression ) ;</p>
<p>FOR ( expression_opt ; expression_opt ; expression_opt ) statement</p>

jump_statement:
<p>GOTO IDENTIFIER ;</p>
<p>CONTINUE ;</p>
<p>BREAK ;</p>
<p>RETURN expression_opt ;</p>

// --- EXPRESSIONS ---
expression:
<p>assignment_expression expression_tail</p>

expression_tail:
<p>, assignment_expression expression_tail</p>
<p>epsilon</p>

assignment_expression:
<p>conditional_expression assignment_tail</p>

assignment_tail:
<p>assignment_operator assignment_expression</p>
<p>epsilon</p>

conditional_expression:
<p>logical_or_expression conditional_tail</p>

conditional_tail:
<p>? expression : conditional_expression</p>
<p>epsilon</p>

constant_expression:
<p>conditional_expression</p>

logical_or_expression:
<p>logical_and_expression logical_or_tail</p>

logical_or_tail:
<p>OR_OP logical_and_expression logical_or_tail</p>
<p>epsilon</p>

logical_and_expression:
<p>inclusive_or_expression logical_and_tail</p>

logical_and_tail:
<p>AND_OP inclusive_or_expression logical_and_tail</p>
<p>epsilon</p>

inclusive_or_expression:
<p>exclusive_or_expression inclusive_or_tail</p>

inclusive_or_tail:
<p>| exclusive_or_expression inclusive_or_tail</p>
<p>epsilon</p>

exclusive_or_expression:
<p>and_expression exclusive_or_tail</p>

exclusive_or_tail:
<p>^ and_expression exclusive_or_tail</p>
<p>epsilon</p>

and_expression:
<p>equality_expression and_tail</p>

and_tail:
<p>& equality_expression and_tail</p>
<p>epsilon</p>

equality_expression:
<p>relational_expression equality_tail</p>

equality_tail:
<p>EQ_OP relational_expression equality_tail</p>
<p>NE_OP relational_expression equality_tail</p>
<p>epsilon</p>

relational_expression:
<p>shift_expression relational_tail</p>

relational_tail:
<p>< shift_expression relational_tail</p>
<p>> shift_expression relational_tail</p>
<p>LE_OP shift_expression relational_tail</p>
<p>GE_OP shift_expression relational_tail</p>
<p>epsilon</p>

shift_expression:
<p>additive_expression shift_tail</p>

shift_tail:
<p>LEFT_OP additive_expression shift_tail</p>
<p>RIGHT_OP additive_expression shift_tail</p>
<p>epsilon</p>

additive_expression:
<p>multiplicative_expression additive_tail</p>

additive_tail:
<p>+ multiplicative_expression additive_tail</p>
<p>- multiplicative_expression additive_tail</p>
<p>epsilon</p>

multiplicative_expression:
<p>cast_expression multiplicative_tail</p>

multiplicative_tail:
<p>* cast_expression multiplicative_tail</p>
<p>/ cast_expression multiplicative_tail</p>
<p>% cast_expression multiplicative_tail</p>
<p>epsilon</p>

cast_expression:
<p>unary_expression</p>
<p>( type_name ) cast_expression</p>

unary_expression:
<p>postfix_expression</p>
<p>INC_OP unary_expression</p>
<p>DEC_OP unary_expression</p>
<p>unary_operator cast_expression</p>
<p>SIZEOF unary_expr_or_type</p>

unary_expr_or_type:
<p>unary_expression</p>
<p>( type_name )</p>

unary_operator:
<p>&</p>
<p>*</p>
<p>+</p>
<p>-</p>
<p>~</p>
<p>!</p>

postfix_expression:
<p>primary_expression postfix_tail</p>

postfix_tail:
<p>[ expression ] postfix_tail</p>
<p>( argument_expression_list_opt ) postfix_tail</p>
<p>. IDENTIFIER postfix_tail</p>
<p>PTR_OP IDENTIFIER postfix_tail</p>
<p>INC_OP postfix_tail</p>
<p>DEC_OP postfix_tail</p>
<p>epsilon</p>

primary_expression:
<p>IDENTIFIER</p>
<p>CONSTANT</p>
<p>STRING_LITERAL</p>
<p>( expression )</p>

argument_expression_list_opt:
<p>argument_expression_list</p>
<p>epsilon</p>

argument_expression_list:
<p>assignment_expression argument_expression_list_tail</p>

argument_expression_list_tail:
<p>, assignment_expression argument_expression_list_tail</p>
<p>epsilon</p>

// --- DECLARATIONS ---
declaration:
<p>declaration_specifiers init_declarator_list_opt ;</p>

declaration_specifiers:
<p>storage_class_specifier declaration_specifiers_opt</p>
<p>type_specifier declaration_specifiers_opt</p>
<p>type_qualifier declaration_specifiers_opt</p>

declaration_specifiers_opt:
<p>declaration_specifiers</p>
<p>epsilon</p>

init_declarator_list_opt:
<p>init_declarator_list</p>
<p>epsilon</p>

init_declarator_list:
<p>init_declarator init_declarator_list_tail</p>

init_declarator_list_tail:
<p>, init_declarator init_declarator_list_tail</p>
<p>epsilon</p>

init_declarator:
<p>declarator initializer_opt</p>

initializer_opt:
<p>= initializer</p>
<p>epsilon</p>

storage_class_specifier:
<p>TYPEDEF</p>
<p>EXTERN</p>
<p>STATIC</p>
<p>AUTO</p>
<p>REGISTER</p>

type_specifier:
<p>VOID</p>
<p>CHAR</p>
<p>SHORT</p>
<p>INT</p>
<p>LONG</p>
<p>FLOAT</p>
<p>DOUBLE</p>
<p>SIGNED</p>
<p>UNSIGNED</p>
<p>struct_or_union_specifier</p>
<p>enum_specifier</p>
<p>TYPE_NAME</p>

struct_or_union_specifier:
<p>struct_or_union struct_body</p>

struct_body:
<p>IDENTIFIER struct_opt</p>
<p>{ struct_declaration_list }</p>

struct_opt:
<p>{ struct_declaration_list }</p>
<p>epsilon</p>

struct_or_union:
<p>STRUCT</p>
<p>UNION</p>

struct_declaration_list:
<p>struct_declaration struct_declaration_list_tail</p>

struct_declaration_list_tail:
<p>struct_declaration struct_declaration_list_tail</p>
<p>epsilon</p>

struct_declaration:
<p>specifier_qualifier_list struct_declarator_list ;</p>

specifier_qualifier_list:
<p>type_specifier specifier_qualifier_list_opt</p>
<p>type_qualifier specifier_qualifier_list_opt</p>

specifier_qualifier_list_opt:
<p>specifier_qualifier_list</p>
<p>epsilon</p>

struct_declarator_list:
<p>struct_declarator struct_declarator_list_tail</p>

struct_declarator_list_tail:
<p>, struct_declarator struct_declarator_list_tail</p>
<p>epsilon</p>

struct_declarator:
<p>declarator bitfield_opt</p>
<p>: constant_expression</p>

bitfield_opt:
<p>: constant_expression</p>
<p>epsilon</p>

enum_specifier:
<p>ENUM enum_body</p>

enum_body:
<p>IDENTIFIER enum_opt</p>
<p>{ enumerator_list }</p>

enum_opt:
<p>{ enumerator_list }</p>
<p>epsilon</p>

enumerator_list:
<p>enumerator enumerator_list_tail</p>

enumerator_list_tail:
<p>, enumerator enumerator_list_tail</p>
<p>epsilon</p>

enumerator:
<p>IDENTIFIER enumerator_val</p>

enumerator_val:
<p>= constant_expression</p>
<p>epsilon</p>

type_qualifier:
<p>CONST</p>
<p>VOLATILE</p>

declarator:
<p>pointer direct_declarator</p>
<p>direct_declarator</p>

direct_declarator:
<p>IDENTIFIER direct_tail</p>
<p>( declarator ) direct_tail</p>

direct_tail:
<p>[ constant_expression_opt ] direct_tail</p>
<p>( parameter_type_list_opt ) direct_tail</p>
<p>epsilon</p>

constant_expression_opt:
<p>constant_expression</p>
<p>epsilon</p>

pointer:
<p>* type_qualifier_list_opt pointer_opt</p>

pointer_opt:
<p>pointer</p>
<p>epsilon</p>

type_qualifier_list_opt:
<p>type_qualifier_list</p>
<p>epsilon</p>

type_qualifier_list:
<p>type_qualifier type_qualifier_list_tail</p>

type_qualifier_list_tail:
<p>type_qualifier type_qualifier_list_tail</p>
<p>epsilon</p>

parameter_type_list_opt:
<p>parameter_type_list</p>
<p>epsilon</p>

parameter_type_list:
<p>parameter_list ellipsis_opt</p>

ellipsis_opt:
<p>, ELLIPSIS</p>
<p>epsilon</p>

parameter_list:
<p>parameter_declaration parameter_list_tail</p>

parameter_list_tail:
<p>, parameter_declaration parameter_list_tail</p>
<p>epsilon</p>

parameter_declaration:
<p>declaration_specifiers parameter_tail</p>

parameter_tail:
<p>declarator</p>
<p>abstract_declarator</p>
<p>epsilon</p>

type_name:
<p>specifier_qualifier_list abstract_declarator_opt</p>

abstract_declarator_opt:
<p>abstract_declarator</p>
<p>epsilon</p>

abstract_declarator:
<p>pointer abstract_direct_opt</p>
<p>direct_abstract_declarator</p>

abstract_direct_opt:
<p>direct_abstract_declarator</p>
<p>epsilon</p>

direct_abstract_declarator:
<p>( abstract_declarator ) direct_abstract_tail</p>
<p>[ constant_expression_opt ] direct_abstract_tail</p>
<p>( parameter_type_list_opt ) direct_abstract_tail</p>

direct_abstract_tail:
<p>[ constant_expression_opt ] direct_abstract_tail</p>
<p>( parameter_type_list_opt ) direct_abstract_tail</p>
<p>epsilon</p>

initializer:
<p>assignment_expression</p>
<p>{ initializer_list comma_opt }</p>

initializer_list:
<p>initializer initializer_list_tail</p>

initializer_list_tail:
<p>, initializer initializer_list_tail</p>
<p>epsilon</p>

assignment_operator:
<p>=</p>
<p>MUL_ASSIGN</p>
<p>DIV_ASSIGN</p>
<p>MOD_ASSIGN</p>
<p>ADD_ASSIGN</p>
<p>SUB_ASSIGN</p>
<p>LEFT_ASSIGN</p>
<p>RIGHT_ASSIGN</p>
<p>AND_ASSIGN</p>
<p>XOR_ASSIGN</p>
<p>OR_ASSIGN</p>
