
primary-expression:
<p>identifier</p>
<p>constant</p>
<p>string-literal</p>
<p>( expression )</p>

postfix-expression:
<p>primary-expression</p>
<p>postfix-expression [ expression ]</p>
<p>postfix-expression ( argument-expression-list )</p>
<p>postfix-expression . identifier</p>
<p>postfix-expression -> identifier</p>
<p>postfix-expression ++</p>
<p>postfix-expression --</p>
<p>( type-name ) { initializer-list }</p>
<p>( type-name ) { initializer-list , }</p>

argument-expression-list:
<p>assignment-expression</p>
<p>argument-expression-list , assignment-expression</p>

unary-expression:
<p>postfix-expression</p>
<p>++ unary-expression</p>
<p>-- unary-expression</p>
<p>unary-operator cast-expression</p>
<p>sizeof unary-expression</p>
<p>sizeof ( type-name ) _Alignof ( type-name )</p>

unary-operator:
<p>& * + - ~ !</p>

cast-expression:
<p>unary-expression</p>
<p>( type-name ) cast-expression</p>

multiplicative-expression:
<p>cast-expression</p>
<p>multiplicative-expression * cast-expression</p>
<p>multiplicative-expression / cast-expression</p>
<p>multiplicative-expression % cast-expression</p>

additive-expression:
<p>multiplicative-expression</p>
<p>additive-expression + multiplicative-expression</p>
<p>additive-expression - multiplicative-expression</p>

shift-expression:
<p>additive-expression</p>
<p>shift-expression << additive-expression</p>
<p>shift-expression >> additive-expression</p>

relational-expression:
<p>shift-expression</p>
<p>relational-expression < shift-expression</p>
<p>relational-expression > shift-expression</p>
<p>relational-expression <= shift-expression</p>
<p>relational-expression >= shift-expression</p>

equality-expression:
<p>relational-expression</p>
<p>equality-expression == relational-expression</p>
<p>equality-expression != relational-expression</p>

AND-expression:
<p>equality-expression</p>
<p>AND-expression & equality-expression</p>

exclusive-OR-expression:
<p>AND-expression</p>
<p>exclusive-OR-expression ^ AND-expression</p>

inclusive-OR-expression:
<p>exclusive-OR-expression</p>
<p>inclusive-OR-expression | exclusive-OR-expression</p>

logical-AND-expression:
<p>inclusive-OR-expression</p>
<p>logical-AND-expression && inclusive-OR-expression</p>

logical-OR-expression:
<p>logical-AND-expression</p>
<p>logical-OR-expression || logical-AND-expression</p>

conditional-expression:
<p>logical-OR-expression</p>
<p>logical-OR-expression ? expression : conditional-expression</p>

assignment-expression:
<p>conditional-expression</p>
<p>unary-expression assignment-operator assignment-expression</p>

assignment-operator:
<p>= *= /= %= += -= <<= >>= &= ^= |=</p>

expression:
<p>assignment-expression</p>
<p>expression , assignment-expression</p>

constant-expression:
<p>conditional-expression</p>

declaration:
<p>declaration-specifiers attribute-seqopt init-declarator-listopt ;</p>
<p>static_assert-declaration</p>

declaration-specifiers:
<p>storage-class-specifier declaration-specifiersopt</p>
<p>type-specifier declaration-specifiersopt</p>
<p>type-qualifier declaration-specifiersopt</p>
<p>function-specifier declaration-specifiersopt</p>
<p>alignment-specifier declaration-specifiersopt</p>

attribute-seq:
<p>attribute attribute-seqopt</p>

attribute:
<p>__asm __based __cdecl __clrcall __fastcall __inline __stdcall __thiscall __vectorcall</p>

init-declarator-list:
<p>init-declarator</p>
<p>init-declarator-list , init-declarator</p>

init-declarator:
<p>declarator</p>
<p>declarator = initializer</p>

storage-class-specifier:
<p>auto</p>
<p>extern</p>
<p>register</p>
<p>static</p>
<p>typedef</p>
<p>__declspec ( extended-decl-modifier-seq )</p>

extended-decl-modifier-seq:
<p>extended-decl-modifieropt</p>
<p>extended-decl-modifier-seq extended-decl-modifier</p>

extended-decl-modifier:
<p>naked</p>
<p>dllimport</p>
<p>dllexport</p>

type-specifier:
<p>void</p>
<p>char</p>
<p>short</p>
<p>int</p>
<p>__int81</p>
<p>__int161</p>
<p>__int321</p>
<p>__int641</p>
<p>long</p>
<p>float</p>
<p>double</p>
<p>signed</p>
<p>unsigned</p>
<p>_Bool</p>
<p>_Complex</p>
<p>atomic-type-specifier</p>
<p>struct-or-union-specifier</p>
<p>enum-specifier</p>
<p>typedef-name</p>

struct-or-union-specifier:
<p>struct-or-union identifieropt { struct-declaration-list }</p>
<p>struct-or-union identifier</p>

struct-or-union:
<p>struct</p>
<p>union</p>

struct-declaration-list:
<p>struct-declaration</p>
<p>struct-declaration-list struct-declaration</p>

struct-declaration:
<p>specifier-qualifier-list struct-declarator-listopt ;</p>
<p>static_assert-declaration</p>

specifier-qualifier-list:
<p>type-specifier specifier-qualifier-listopt</p>
<p>type-qualifier specifier-qualifier-listopt</p>
<p>alignment-specifier specifier-qualifier-listopt</p>

struct-declarator-list:
<p>struct-declarator</p>
<p>struct-declarator-list , struct-declarator</p>

struct-declarator:
<p>declarator</p>
<p>declaratoropt : constant-expression</p>

enum-specifier:
<p>enum identifieropt { enumerator-list }</p>
<p>enum identifieropt { enumerator-list , }</p>
<p>enum identifier</p>

enumerator-list:
<p>enumerator</p>
<p>enumerator-list , enumerator</p>

enumerator:
<p>enumeration-constant</p>
<p>enumeration-constant = constant-expression</p>

atomic-type-specifier:
<p>_Atomic ( type-name )</p>

type-qualifier:
<p>const</p>
<p>restrict</p>
<p>volatile</p>
<p>_Atomic</p>

function-specifier:
<p>inline</p>
<p>_Noreturn</p>

alignment-specifier:
<p>_Alignas ( type-name )</p>
<p>_Alignas ( constant-expression )</p>

declarator:
<p>pointeropt direct-declarator</p>

direct-declarator:
<p>identifier</p>
<p>( declarator )</p>
<p>direct-declarator [ type-qualifier-listopt assignment-expressionopt ]</p>
<p>direct-declarator [ static type-qualifier-listopt assignment-expression ]</p>
<p>direct-declarator [ type-qualifier-list static assignment-expression ]</p>
<p>direct-declarator [ type-qualifier-listopt * ]</p>
<p>direct-declarator ( parameter-type-list )</p>
<p>direct-declarator ( identifier-listopt )</p>

pointer:
<p>* type-qualifier-listopt</p>
<p>* type-qualifier-listopt pointer</p>

type-qualifier-list:
<p>type-qualifier</p>
<p>type-qualifier-list type-qualifier</p>

parameter-type-list:
<p>parameter-list</p>
<p>parameter-list , ...</p>

parameter-list:
<p>parameter-declaration</p>
<p>parameter-list , parameter-declaration</p>

parameter-declaration:
<p>declaration-specifiers declarator</p>
<p>declaration-specifiers abstract-declaratoropt</p>

identifier-list:
<p>identifier</p>
<p>identifier-list , identifier</p>

type-name:
<p>specifier-qualifier-list abstract-declaratoropt</p>

abstract-declarator:
<p>pointer</p>
<p>pointeropt direct-abstract-declarator</p>

direct-abstract-declarator:
<p>( abstract-declarator )</p>
<p>direct-abstract-declarator [ type-qualifier-listopt assignment-expressionopt ]</p>
<p>direct-abstract-declarator [ static type-qualifier-listopt assignment-expression ]</p>
<p>direct-abstract-declarator [ type-qualifier-list static assignment-expression ]</p>
<p>direct-abstract-declarator [ type-qualifier-listopt * ]</p>
<p>direct-abstract-declaratoropt ( parameter-type-listopt )</p>

typedef-name:
<p>identifier</p>

initializer:
<p>assignment-expression</p>
<p>{ initializer-list }</p>
<p>{ initializer-list , }</p>

initializer-list:
<p>designationopt initializer</p>
<p>initializer-list , designationopt initializer</p>

designation:
<p>designator-list =</p>

designator-list:
<p>designator</p>
<p>designator-list designator</p>

designator:
<p>[ constant-expression ]</p>
<p>. identifier</p>

static-assert-declaration:
<p>_Static_assert ( constant-expression , string-literal ) ;</p>

statement:
<p>labeled-statement</p>
<p>compound-statement</p>
<p>expression-statement</p>
<p>selection-statement</p>
<p>iteration-statement</p>
<p>jump-statement</p>

jump-statement:
<p>goto identifier ;</p>
<p>continue ;</p>
<p>break ;</p>
<p>return expressionopt ;</p>

compound-statement:
<p>{ declaration-listopt statement-listopt }</p>

declaration-list:
<p>declaration</p>
<p>declaration-list declaration</p>

statement-list:
<p>statement</p>
<p>statement-list statement</p>

expression-statement:
<p>expressionopt ;</p>

iteration-statement:
<p>while ( expression ) statement</p>
<p>do statement while ( expression ) ;</p>
<p>for ( expressionopt ; expressionopt ; expressionopt ) statement</p>

selection-statement:
<p>if ( expression ) statement</p>
<p>if ( expression ) statement else statement</p>
<p>switch ( expression ) statement</p>

labeled-statement:
<p>case constant-expression : statement</p>

token:
<p>keyword</p>
<p>identifier</p>
<p>constant</p>
<p>string-literal</p>
<p>punctuator</p>

preprocessing-token:
<p>header-name</p>
<p>identifier</p>
<p>pp-number</p>
<p>character-constant</p>
<p>string-literal</p>
<p>punctuator</p>

keyword:
<p>auto</p>
<p>break</p>
<p>case</p>
<p>char</p>
<p>const</p>
<p>continue</p>
<p>default</p>
<p>do</p>
<p>double</p>
<p>else</p>
<p>enum</p>
<p>extern</p>
<p>float</p>
<p>for</p>
<p>goto</p>
<p>if</p>
<p>inline</p>
<p>int</p>
<p>long</p>
<p>register</p>
<p>restrict</p>
<p>return</p>
<p>short</p>
<p>signed</p>
<p>sizeof</p>
<p>static</p>
<p>struct</p>
<p>switch</p>
<p>typedef</p>
<p>union</p>
<p>unsigned</p>
<p>void</p>
<p>volatile</p>
<p>while</p>
<p>_Alignas</p>
<p>_Alignof</p>
<p>_Atomic</p>
<p>_Bool</p>
<p>_Complex</p>
<p>_Generic</p>
<p>_Imaginary</p>
<p>_Noreturn</p>
<p>_Static_assert</p>
<p>_Thread_local</p>

identifier:
<p>identifier-nondigit</p>
<p>identifier identifier-nondigit</p>
<p>identifier digit</p>

identifier-nondigit:
<p>nondigit</p>
<p>universal-character-name</p>

nondigit:
<p>_</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>d</p>
<p>e</p>
<p>f</p>
<p>g</p>
<p>h</p>
<p>i</p>
<p>j</p>
<p>k</p>
<p>l</p>
<p>m</p>
<p>n</p>
<p>o</p>
<p>p</p>
<p>q</p>
<p>r</p>
<p>s</p>
<p>t</p>
<p>u</p>
<p>v</p>
<p>w</p>
<p>x</p>
<p>y</p>
<p>z</p>
<p>A</p>
<p>B</p>
<p>C</p>
<p>D</p>
<p>E</p>
<p>F</p>
<p>G</p>
<p>H</p>
<p>I</p>
<p>J</p>
<p>K</p>
<p>L</p>
<p>M</p>
<p>N</p>
<p>O</p>
<p>P</p>
<p>Q</p>
<p>R</p>
<p>S</p>
<p>T</p>
<p>U</p>
<p>V</p>
<p>W</p>
<p>X</p>
<p>Y</p>
<p>Z</p>

digit:
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>

universal-character-name:
<p>\u hex-quad</p>
<p>\U hex-quad hex-quad</p>

hex-quad:
<p>hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit</p>

constant:
<p>integer-constant</p>
<p>floating-constant</p>
<p>enumeration-constant</p>
<p>character-constant</p>

integer-constant:
<p>decimal-constantinteger-suffix</p>
<p>binary-constant1integer-suffix</p>
<p>octal-constantinteger-suffix</p>
<p>hexadecimal-constantinteger-suffix</p>

decimal-constant:
<p>nonzero-digit</p>
<p>decimal-constant digit</p>

binary-constant:
<p>binary-prefix binary-digit</p>
<p>binary-constant binary-digit</p>

binary-prefix:
<p>0b</p>
<p>0B</p>

binary-digit:
<p>0</p>
<p>1</p>

octal-constant:
<p>0</p>
<p>octal-constant octal-digit</p>

hexadecimal-constant:
<p>hexadecimal-prefix hexadecimal-digit</p>
<p>hexadecimal-constant hexadecimal-digit</p>

hexadecimal-prefix:
<p>0x</p>
<p>0X</p>

nonzero-digit:
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>

octal-digit:
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>

hexadecimal-digit:
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>a</p>
<p>b</p>
<p>c</p>
<p>d</p>
<p>e</p>
<p>f</p>
<p>A</p>
<p>B</p>
<p>C</p>
<p>D</p>
<p>E</p>
<p>F</p>

integer-suffix:
<p>unsigned-suffix long-suffix</p>
<p>unsigned-suffix long-long-suffix</p>
<p>long-suffix unsigned-suffix</p>
<p>long-long-suffix unsigned-suffix</p>

unsigned-suffix:
<p>u</p>
<p>U</p>

long-suffix:
<p>l</p>
<p>L</p>

long-long-suffix:
<p>ll</p>
<p>LL</p>

floating-constant:
<p>decimal-floating-constant</p>
<p>hexadecimal-floating-constant</p>

decimal-floating-constant:
<p>fractional-constant exponent-part floating-suffix</p>
<p>digit-sequence exponent-part floating-suffix</p>

hexadecimal-floating-constant:
<p>hexadecimal-prefix hexadecimal-fractional-constant binary-exponent-part floating-suffix</p>
<p>hexadecimal-prefix hexadecimal-digit-sequence binary-exponent-part floating-suffix</p>

fractional-constant:
<p>digit-sequence . digit-sequence</p>
<p>digit-sequence .</p>

exponent-part:
<p>e sign digit-sequence</p>
<p>E sign digit-sequence</p>

sign:
<p>+</p>
<p>-</p>

digit-sequence:
<p>digit</p>
<p>digit-sequence digit</p>

hexadecimal-fractional-constant:
<p>hexadecimal-digit-sequence . hexadecimal-digit-sequence</p>
<p>hexadecimal-digit-sequence .</p>

binary-exponent-part:
<p>p sign digit-sequence</p>
<p>P sign digit-sequence</p>

hexadecimal-digit-sequence:
<p>hexadecimal-digit</p>
<p>hexadecimal-digit-sequence hexadecimal-digit</p>

floating-suffix:
<p>f</p>
<p>l</p>
<p>F</p>
<p>L</p>

enumeration-constant:
<p>identifier</p>

character-constant:
<p>' c-char-sequence '</p>
<p>L' c-char-sequence '</p>

c-char-sequence:
<p>c-char</p>
<p>c-char-sequence c-char</p>

c-char:
<p>digit</p>
<p>nondigit</p>
<p>escape-sequence</p>

escape-sequence:
<p>simple-escape-sequence</p>
<p>octal-escape-sequence</p>
<p>hexadecimal-escape-sequence</p>
<p>universal-character-name</p>

simple-escape-sequence:
<p>\a</p>
<p>\b</p>
<p>\f</p>
<p>\n</p>
<p>\r</p>
<p>\t</p>
<p>\v</p>
<p>\'</p>
<p>\"</p>
<p>\\</p>
<p>\?</p>

octal-escape-sequence:
<p>\ octal-digit</p>
<p>\ octal-digit octal-digit</p>
<p>\ octal-digit octal-digit octal-digit</p>

hexadecimal-escape-sequence:
<p>\x hexadecimal-digit</p>
<p>hexadecimal-escape-sequence hexadecimal-digit</p>

string-literal:
<p>encoding-prefix " s-char-sequence "</p>

encoding-prefix:
<p>u8</p>
<p>u</p>
<p>U</p>
<p>L</p>

s-char-sequence:
<p>s-char</p>
<p>s-char-sequence s-char</p>

s-char:
<p>digit</p>
<p>nondigit</p>
<p>escape-sequence</p>

punctuator:
<p>[</p>
<p>]</p>
<p>(</p>
<p>)</p>
<p>{</p>
<p>}</p>
<p>.</p>
<p>-></p>
<p>++</p>
<p>--</p>
<p>&</p>
<p>*</p>
<p>+</p>
<p>-</p>
<p>~</p>
<p>!</p>
<p>/</p>
<p>%</p>
<p><<</p>
<p>>></p>
<p><</p>
<p>></p>
<p><=</p>
<p>>=</p>
<p>==</p>
<p>!=</p>
<p>^</p>
<p>|</p>
<p>&&</p>
<p>||</p>
<p>?</p>
<p>:</p>
<p>;</p>
<p>...</p>
<p>=</p>
<p>*=</p>
<p>/=</p>
<p>%=</p>
<p>+=</p>
<p>-=</p>
<p><<=</p>
<p>>>=</p>
<p>&=</p>
<p>^=</p>
<p>|=</p>
<p>,</p>
<p>#</p>
<p>##</p>
<p><:</p>
<p>:></p>
<p><%</p>
<p>%></p>
<p>%:</p>
<p>%:%:</p>

header-name:
<p>< h-char-sequence ></p>
<p>" q-char-sequence "</p>

h-char-sequence:
<p>h-char</p>
<p>h-char-sequence h-char</p>

h-char:
<p>digit</p>
<p>nondigit</p>

q-char-sequence:
<p>q-char</p>
<p>q-char-sequence q-char</p>

q-char:
<p>digit</p>
<p>nondigit</p>

pp-number:
<p>digit</p>
<p>. digit</p>
<p>pp-number digit</p>
<p>pp-number identifier-nondigit</p>
<p>pp-number e sign</p>
<p>pp-number E sign</p>
<p>pp-number p sign</p>
<p>pp-number P sign</p>
<p>pp-number .</p>

