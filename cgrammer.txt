
primary-expression:
<p>identifier</p>
<p>constant</p>
<p>string-literal</p>
<p>( expression )</p>

postfix-expression:
<p>primary-expression</p>
<p>postfix-expression [ expression ]</p>
<p>postfix-expression ( argument-expression-list )</p>
<p>postfix-expression . identifier</p>
<p>postfix-expression -> identifier</p>
<p>postfix-expression ++</p>
<p>postfix-expression --</p>
<p>( type-name ) { initializer-list }</p>
<p>( type-name ) { initializer-list , }</p>

argument-expression-list:
<p>assignment-expression</p>
<p>argument-expression-list , assignment-expression</p>

unary-expression:
<p>postfix-expression</p>
<p>++ unary-expression</p>
<p>-- unary-expression</p>
<p>unary-operator cast-expression</p>
<p>sizeof unary-expression</p>
<p>sizeof ( type-name ) _Alignof ( type-name )</p>

unary-operator:
<p>&</p>
<p>*</p>
<p>+</p>
<p>-</p>
<p>~</p>
<p>!</p>

cast-expression:
<p>unary-expression</p>
<p>( type-name ) cast-expression</p>

multiplicative-expression:
<p>cast-expression</p>
<p>multiplicative-expression * cast-expression</p>
<p>multiplicative-expression / cast-expression</p>
<p>multiplicative-expression % cast-expression</p>

additive-expression:
<p>multiplicative-expression</p>
<p>additive-expression + multiplicative-expression</p>
<p>additive-expression - multiplicative-expression</p>

shift-expression:
<p>additive-expression</p>
<p>shift-expression << additive-expression</p>
<p>shift-expression >> additive-expression</p>

relational-expression:
<p>shift-expression</p>
<p>relational-expression < shift-expression</p>
<p>relational-expression > shift-expression</p>
<p>relational-expression <= shift-expression</p>
<p>relational-expression >= shift-expression</p>

equality-expression:
<p>relational-expression</p>
<p>equality-expression == relational-expression</p>
<p>equality-expression != relational-expression</p>

AND-expression:
<p>equality-expression</p>
<p>AND-expression & equality-expression</p>

exclusive-OR-expression:
<p>AND-expression</p>
<p>exclusive-OR-expression ^ AND-expression</p>

inclusive-OR-expression:
<p>exclusive-OR-expression</p>
<p>inclusive-OR-expression | exclusive-OR-expression</p>

logical-AND-expression:
<p>inclusive-OR-expression</p>
<p>logical-AND-expression && inclusive-OR-expression</p>

logical-OR-expression:
<p>logical-AND-expression</p>
<p>logical-OR-expression || logical-AND-expression</p>

conditional-expression:
<p>logical-OR-expression</p>
<p>logical-OR-expression ? expression : conditional-expression</p>

assignment-expression:
<p>conditional-expression</p>
<p>unary-expression assignment-operator assignment-expression</p>

assignment-operator:
<p>=</p>
<p>*=</p>
<p>/=</p>
<p>%=</p>
<p>+=</p>
<p>-=</p>
<p><<=</p>
<p>>>=</p>
<p>&=</p>
<p>^=</p>
<p>|=</p>

expression:
<p>assignment-expression</p>
<p>expression , assignment-expression</p>

constant-expression:
<p>conditional-expression</p>

declaration:
<p>declaration-specifiers attribute-seq init-declarator-list ;</p>
<p>static_assert-declaration</p>

declaration-specifiers:
<p>storage-class-specifier declaration-specifiers</p>
<p>type-specifier declaration-specifiers</p>
<p>type-qualifier declaration-specifiers</p>
<p>function-specifier declaration-specifiers</p>

attribute-seq:
<p>attribute attribute-seq</p>

attribute:
<p>__asm</p>
<p>__based</p>
<p>__cdecl</p>
<p>__clrcall</p>
<p>__fastcall</p>
<p>__inline</p>
<p>__stdcall</p>
<p>__thiscall</p>
<p>__vectorcall</p>

init-declarator-list:
<p>init-declarator</p>
<p>init-declarator-list , init-declarator</p>

init-declarator:
<p>declarator</p>
<p>declarator = initializer</p>

storage-class-specifier:
<p>auto</p>
<p>extern</p>
<p>register</p>
<p>static</p>
<p>typedef</p>
<p>__declspec ( extended-decl-modifier-seq )</p>

extended-decl-modifier-seq:
<p>extended-decl-modifier</p>
<p>extended-decl-modifier-seq extended-decl-modifier</p>

extended-decl-modifier:
<p>naked</p>
<p>dllimport</p>
<p>dllexport</p>

type-specifier:
<p>void</p>
<p>char</p>
<p>short</p>
<p>int</p>
<p>long</p>
<p>float</p>
<p>double</p>
<p>signed</p>
<p>unsigned</p>
<p>struct-or-union-specifier</p>
<p>enum-specifier</p>
<p>typedef-name</p>

struct-or-union-specifier:
<p>struct-or-union identifier { struct-declaration-list }</p>
<p>struct-or-union identifier</p>

struct-or-union:
<p>struct</p>
<p>union</p>

struct-declaration-list:
<p>struct-declaration</p>
<p>struct-declaration-list struct-declaration</p>

struct-declaration:
<p>specifier-qualifier-list struct-declarator-list ;</p>
<p>static_assert-declaration</p>

specifier-qualifier-list:
<p>type-specifier specifier-qualifier-list</p>
<p>type-qualifier specifier-qualifier-list</p>

struct-declarator-list:
<p>struct-declarator</p>
<p>struct-declarator-list , struct-declarator</p>

struct-declarator:
<p>declarator</p>
<p>declarator : constant-expression</p>

enum-specifier:
<p>enum identifier { enumerator-list }</p>
<p>enum identifier { enumerator-list , }</p>
<p>enum identifier</p>

enumerator-list:
<p>enumerator</p>
<p>enumerator-list , enumerator</p>

enumerator:
<p>enumeration-constant</p>
<p>enumeration-constant = constant-expression</p>

type-qualifier:
<p>const</p>
<p>restrict</p>
<p>volatile</p>

function-specifier:
<p>inline</p>
<p>_Noreturn</p>

declarator:
<p>pointer direct-declarator</p>

direct-declarator:
<p>identifier</p>
<p>( declarator )</p>
<p>direct-declarator [ type-qualifier-list assignment-expression ]</p>
<p>direct-declarator [ static type-qualifier-list assignment-expression ]</p>
<p>direct-declarator [ type-qualifier-list static assignment-expression ]</p>
<p>direct-declarator [ type-qualifier-list * ]</p>
<p>direct-declarator ( parameter-type-list )</p>
<p>direct-declarator ( identifier-list )</p>

pointer:
<p>* type-qualifier-list</p>
<p>* type-qualifier-list pointer</p>

type-qualifier-list:
<p>type-qualifier</p>
<p>type-qualifier-list type-qualifier</p>

parameter-type-list:
<p>parameter-list</p>
<p>parameter-list , ...</p>

parameter-list:
<p>parameter-declaration</p>
<p>parameter-list , parameter-declaration</p>

parameter-declaration:
<p>declaration-specifiers declarator</p>
<p>declaration-specifiers abstract-declarator</p>

identifier-list:
<p>identifier</p>
<p>identifier-list , identifier</p>

type-name:
<p>specifier-qualifier-list abstract-declarator</p>

abstract-declarator:
<p>pointer</p>
<p>pointer direct-abstract-declarator</p>

direct-abstract-declarator:
<p>( abstract-declarator )</p>
<p>direct-abstract-declarator [ type-qualifier-list assignment-expression ]</p>
<p>direct-abstract-declarator [ static type-qualifier-list assignment-expression ]</p>
<p>direct-abstract-declarator [ type-qualifier-list static assignment-expression ]</p>
<p>direct-abstract-declarator [ type-qualifier-list * ]</p>
<p>direct-abstract-declarator ( parameter-type-list )</p>

typedef-name:
<p>identifier</p>

initializer:
<p>assignment-expression</p>
<p>{ initializer-list }</p>
<p>{ initializer-list , }</p>

initializer-list:
<p>designation initializer</p>
<p>initializer-list , designation initializer</p>

designation:
<p>designator-list =</p>

designator-list:
<p>designator</p>
<p>designator-list designator</p>

designator:
<p>[ constant-expression ]</p>
<p>. identifier</p>

static-assert-declaration:
<p>_Static_assert ( constant-expression , string-literal ) ;</p>

statement:
<p>labeled-statement</p>
<p>compound-statement</p>
<p>expression-statement</p>
<p>selection-statement</p>
<p>iteration-statement</p>
<p>jump-statement</p>

jump-statement:
<p>goto identifier ;</p>
<p>continue ;</p>
<p>break ;</p>
<p>return expression ;</p>

compound-statement:
<p>{ declaration-list statement-list }</p>

declaration-list:
<p>declaration</p>
<p>declaration-list declaration</p>

statement-list:
<p>statement</p>
<p>statement-list statement</p>

expression-statement:
<p>expression ;</p>

iteration-statement:
<p>while ( expression ) statement</p>
<p>do statement while ( expression ) ;</p>
<p>for ( expression ; expression ; expression ) statement</p>

selection-statement:
<p>if ( expression ) statement</p>
<p>if ( expression ) statement else statement</p>
<p>switch ( expression ) statement</p>

labeled-statement:
<p>case constant-expression : statement</p>
